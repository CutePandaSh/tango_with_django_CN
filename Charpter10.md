# 10 Cookies 和 Session

## 10.2 Sessions 和 无状态协议

网页浏览器（客户端）和服务器之间的通讯都是被封装在HTTP协议中的。就如同之前所提及的，HTTP是无状态协议，这个意味着每次运行网页浏览器的客户端电脑，向某个资源进行请求(HTTP _get_)或者提交(HTTP _post_)的时候，都必须与服务器建立一个新的连接(TCP 连接)。

由于在客户端和服务器之间没有持久性的连接，所以在两端的软件就不能简单的依靠这种连接来保持 _会话状态(session state)_。例如，客户端每次都需要告诉服务器端目前是哪个用户在当前的电脑上登陆的。这被认为是客户端和服务器之间的一种 _对话_ 模式，这也是 _会话 session_ 的基础 —— 一种半持久性的信息交换。作为一种无状态协议，HTTP要持有会话状态是具有挑战性的，但是幸运的是，目前已经有数种技术让我们可以绕过这个问题。

目前持有状态最常用的方法是将会话ID用cookie的形式存储在客户端的电脑上。会话ID可以被认为是一个在特定的web应用程序上能标示当前会话的唯一性的令牌(一个字符的序列，或者是一个 _字符串 string_)。这个解决方案，并不会将所有的信息(例如用户登陆名、姓名、密码等)都使用cookie存储在客户端上，只有会话ID才会被存储，并且这个ID对应着服务器上的一个数据结构。在这个数据结构中，你可以存放你所需要的所有信息。这是一个 **安全得多** 的方法来存储用户信息，因为这种情况下，即使是使用不安全的客户端或者连接被监听也不能破坏会话中的信息。

如果你正在使用一个正确配置的现代浏览器，那么它就应该是支持cookie的。目前绝大部分的网站都会在你访问的时候创建一个新的 _会话 session_。你现在就可以自己查看一下——请查看下方的截图。在谷歌Chrome浏览器中，你可以使用Chrome开发者工具来查看当前访问的网站所建立的cookie，你可以在 _Chrome_ 的菜单中的 _更多工具_ 下，找到 _开发者工具_ 的选项。在开发者工具面板打开情况下，请点击 _Application_ 页片，然后在左下方的 _Storage_ 菜单下找到 _Cookies_ 选项。如果你是在打开 Rango 页面的状态下，进行的操作，那么你就会发现一个名字为 `sessionid` 的cookie。这个`sessionid` cookie包含了一串的字母和数字，这个就是Django用来识别当前电脑会话的唯一性标志。使用这个会话ID，你的会话的所有细节信息就能被访问到了——但是这些信息仅仅是在 _服务器端_ 存储的。

> ### 如果没有cookie
>
> 另一个不使用cookie来持久化状态信息的方法，就是将会话ID编码后放入网络地址 URL 中。例如你可能曾经在PHP驱动的网站上看到过类似如下这样的地址：
> `http://www.site.com/index.php?sessid=someseeminglyrandomandlongstring1234`
>
> 这意味着你就不需要在客户端存储cookie了，但是访问地址将会变得非常丑陋。这种形式的访问地址违反了Django的原则——简单、人性化的访问地址。

## 10.3 在Django中配置Session

虽然在默认情况下，session的功能应该已经被正确设置，并且能够正常使用了，但是详细了解Django的哪些模块提供了哪些对应的功能，是学习Django很好的实践过程。对于session这个功能来说，是由Django的 _中间件middleware_ 来实现的。

让我们按照顺序来检查每一个功能吧，先打开你Django项目文件夹下的`setting.py` 文件。在这个文件中，你能找到一个名为`MIDDLEWARE`的列表，在这个列表中，可以找到一个用字符串`django.contrib.sessions.middleware.SessionMiddleware`表示的模块。如果你没有在列表中看到它，那么现在就马上把它加入这个列表。这个名为`SessionMiddleware`的中间件，就是负责建立唯一`sessionid` cookie的功能模块。在设计上，SessionMiddleware 中间件模块，是可以非常灵活的支持各种不同的方式来存储会话信息的。这里举例了几个不同的解决方案——你可以把所有的信息都存到一个文件里面，或者数据苦，甚至可以存储在内存缓存区中。